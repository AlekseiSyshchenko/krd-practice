Логика работы приложения.

У нас есть модуль Resource с методом connection,
класс PostsController с методами работы с постами и класс Router с методами init и resources.
К классу PostsController мы примешиваем модуль Resource с помощью extend. После этого
его методы становятся доступны в классе как методы класса, поэтому мы можем не создавая инстанс
обратиться к методу из модуля PostsController.connection(@routes['posts']).

Выполнение начинается созданием экемпляра router = Router.new, в конструкторе создается переменная экземпляра - пустой хеш:
@routes = {}, затем выполняется метод экземпляра router.init. 
В init мы вызываем метод resources(PostsController, 'posts'), передав класс и строку, там создаем экземпляр PostsController и заносим один элемент
в хеш @routes = {}, а именно многомерный вложенный хеш со ссылками на методы в PostsController. Элемент один так как
пока реализована только работа с постами.
Ключ posts имеет значениями команды, которые тоже являются ключами, причем Get имеет значением еще один хеш и уже в нем ключи 'index' и 'show' ссылаются на соответствующие методы. 
Далее в цикле просим выбрать с чем мы будем работать, пока реализована только работа с постами.
И обращаемся к методу PostsController.connection(@routes['posts']) if choise == '1' модуля Resource, передавая
наш хеш, содержащийся в posts.
Там в цикле спрашиваем какой метод взаимодействия будем применять (GET/POST/PUT/DELETE), если выбран GET дополнительно запрашиваем действие index/show.
Дальше проверяем, если мы не выбирали GET, то действие мы тоже не выбирали и оно будет nil, тогда обращаемся по
ключу к хешу и вызываем соответствующий метод (у нас там уже есть ссылки на них), если же хоть какое-то действие
есть, то обращаемся к двухмерному хешу GET. action.nil? ? routes[verb].call : routes[verb][action].call
В PostsController все посты хранятся в массиве @posts = [] и представляют собой строки. 
Проверки выбора команд и наличия постов тривиальны, как и сама работа с массивом строк.
В случае выбора q выходим сначала из цикла в connection, затем также можем выйти из основного цикла программы в init.




